// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum AbilityType : int {
    Dash,
    OrbitalSupport,
    Return,
  }
  public enum EAbilityEndCondition : int {
    Duration = 0,
    Event = 1,
  }
  public enum EHitTargetType : int {
    None,
    Mechanic,
    Nexus,
  }
  public enum EKCCCollisionSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCIgnoreSource : byte {
    None = 0,
    Entity = 1,
    Collider = 2,
  }
  public enum EKCCProcessorSource : byte {
    None = 0,
    Modifier = 1,
    StaticCollider = 2,
    EntityCollider = 3,
  }
  public enum ESpreadDirection : int {
    HORIZONTAL,
    VERTICAL,
    GRID,
  }
  public enum ESpreadShape : int {
    PLANE,
    CIRCULAR,
  }
  public enum EWeaponType : int {
    MainWeapon,
    SubWeapon,
  }
  public enum GameState : int {
    Off = 0,
    Lobby,
    Pregame,
    Intro,
    Countdown,
    Game,
    Outro,
    Postgame,
  }
  public enum SkillStatus : int {
    Ready,
    Casting,
    CoolTime,
  }
  public enum Team : int {
    Blue,
    Green,
    Red,
    None,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    MouseLeftButton = 1 << 0,
    MainWeaponFire = 1 << 1,
    FirstSkill = 1 << 2,
    SecondSkill = 1 << 3,
    ThirdSkill = 1 << 4,
    FourthSkill = 1 << 5,
    FifthSkill = 1 << 6,
    SixthSkill = 1 << 7,
    SeventhSkill = 1 << 8,
    EighthSkill = 1 << 9,
    NinthSkill = 1 << 10,
    TenthSkill = 1 << 11,
    Return = 1 << 12,
    ChangeWeapon = 1 << 13,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Ability {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public AbilityType AbilityType;
    [FieldOffset(48)]
    [ExcludeFromPrototype()]
    public CountdownTimer InputBufferTimer;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public CountdownTimer DelayTimer;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public CountdownTimer DurationTimer;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public EAbilityEndCondition EndCondition;
    [FieldOffset(8)]
    public AssetRef<AbilityData> AbilityData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6343;
        hash = hash * 31 + (Int32)AbilityType;
        hash = hash * 31 + InputBufferTimer.GetHashCode();
        hash = hash * 31 + DelayTimer.GetHashCode();
        hash = hash * 31 + DurationTimer.GetHashCode();
        hash = hash * 31 + (Int32)EndCondition;
        hash = hash * 31 + AbilityData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Ability*)ptr;
        serializer.Stream.Serialize((Int32*)&p->AbilityType);
        serializer.Stream.Serialize((Int32*)&p->EndCondition);
        AssetRef.Serialize(&p->AbilityData, serializer);
        Quantum.CountdownTimer.Serialize(&p->DelayTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->DurationTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->InputBufferTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ActiveAbilityInfo {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 ActiveAbilityIndex;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FPVector3 CastDirection;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPQuaternion CastRotation;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FPVector3 CastVelocity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2017;
        hash = hash * 31 + ActiveAbilityIndex.GetHashCode();
        hash = hash * 31 + CastDirection.GetHashCode();
        hash = hash * 31 + CastRotation.GetHashCode();
        hash = hash * 31 + CastVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ActiveAbilityInfo*)ptr;
        serializer.Stream.Serialize(&p->ActiveAbilityIndex);
        FPVector3.Serialize(&p->CastDirection, serializer);
        FPVector3.Serialize(&p->CastVelocity, serializer);
        FPQuaternion.Serialize(&p->CastRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CountdownTimer {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP TimeLeft;
    [FieldOffset(0)]
    public FP StartTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8641;
        hash = hash * 31 + TimeLeft.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CountdownTimer*)ptr;
        FP.Serialize(&p->StartTime, serializer);
        FP.Serialize(&p->TimeLeft, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GameController {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public GameState State;
    [FieldOffset(8)]
    public FP GameTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2393;
        hash = hash * 31 + (Int32)State;
        hash = hash * 31 + GameTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GameController*)ptr;
        serializer.Stream.Serialize((Int32*)&p->State);
        FP.Serialize(&p->GameTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 192;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Byte MovementEncoded;
    [FieldOffset(96)]
    public Button MouseLeftButton;
    [FieldOffset(8)]
    public FP ScreenPositionX;
    [FieldOffset(16)]
    public FP ScreenPositionY;
    [FieldOffset(84)]
    public Button MainWeaponFire;
    [FieldOffset(60)]
    public Button FirstSkill;
    [FieldOffset(132)]
    public Button SecondSkill;
    [FieldOffset(180)]
    public Button ThirdSkill;
    [FieldOffset(72)]
    public Button FourthSkill;
    [FieldOffset(48)]
    public Button FifthSkill;
    [FieldOffset(156)]
    public Button SixthSkill;
    [FieldOffset(144)]
    public Button SeventhSkill;
    [FieldOffset(36)]
    public Button EighthSkill;
    [FieldOffset(108)]
    public Button NinthSkill;
    [FieldOffset(168)]
    public Button TenthSkill;
    [FieldOffset(120)]
    public Button Return;
    [FieldOffset(24)]
    public Button ChangeWeapon;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + MovementEncoded.GetHashCode();
        hash = hash * 31 + MouseLeftButton.GetHashCode();
        hash = hash * 31 + ScreenPositionX.GetHashCode();
        hash = hash * 31 + ScreenPositionY.GetHashCode();
        hash = hash * 31 + MainWeaponFire.GetHashCode();
        hash = hash * 31 + FirstSkill.GetHashCode();
        hash = hash * 31 + SecondSkill.GetHashCode();
        hash = hash * 31 + ThirdSkill.GetHashCode();
        hash = hash * 31 + FourthSkill.GetHashCode();
        hash = hash * 31 + FifthSkill.GetHashCode();
        hash = hash * 31 + SixthSkill.GetHashCode();
        hash = hash * 31 + SeventhSkill.GetHashCode();
        hash = hash * 31 + EighthSkill.GetHashCode();
        hash = hash * 31 + NinthSkill.GetHashCode();
        hash = hash * 31 + TenthSkill.GetHashCode();
        hash = hash * 31 + Return.GetHashCode();
        hash = hash * 31 + ChangeWeapon.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.MouseLeftButton: return MouseLeftButton.IsDown;
        case InputButtons.MainWeaponFire: return MainWeaponFire.IsDown;
        case InputButtons.FirstSkill: return FirstSkill.IsDown;
        case InputButtons.SecondSkill: return SecondSkill.IsDown;
        case InputButtons.ThirdSkill: return ThirdSkill.IsDown;
        case InputButtons.FourthSkill: return FourthSkill.IsDown;
        case InputButtons.FifthSkill: return FifthSkill.IsDown;
        case InputButtons.SixthSkill: return SixthSkill.IsDown;
        case InputButtons.SeventhSkill: return SeventhSkill.IsDown;
        case InputButtons.EighthSkill: return EighthSkill.IsDown;
        case InputButtons.NinthSkill: return NinthSkill.IsDown;
        case InputButtons.TenthSkill: return TenthSkill.IsDown;
        case InputButtons.Return: return Return.IsDown;
        case InputButtons.ChangeWeapon: return ChangeWeapon.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.MouseLeftButton: return MouseLeftButton.WasPressed;
        case InputButtons.MainWeaponFire: return MainWeaponFire.WasPressed;
        case InputButtons.FirstSkill: return FirstSkill.WasPressed;
        case InputButtons.SecondSkill: return SecondSkill.WasPressed;
        case InputButtons.ThirdSkill: return ThirdSkill.WasPressed;
        case InputButtons.FourthSkill: return FourthSkill.WasPressed;
        case InputButtons.FifthSkill: return FifthSkill.WasPressed;
        case InputButtons.SixthSkill: return SixthSkill.WasPressed;
        case InputButtons.SeventhSkill: return SeventhSkill.WasPressed;
        case InputButtons.EighthSkill: return EighthSkill.WasPressed;
        case InputButtons.NinthSkill: return NinthSkill.WasPressed;
        case InputButtons.TenthSkill: return TenthSkill.WasPressed;
        case InputButtons.Return: return Return.WasPressed;
        case InputButtons.ChangeWeapon: return ChangeWeapon.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->MovementEncoded);
        FP.Serialize(&p->ScreenPositionX, serializer);
        FP.Serialize(&p->ScreenPositionY, serializer);
        Button.Serialize(&p->ChangeWeapon, serializer);
        Button.Serialize(&p->EighthSkill, serializer);
        Button.Serialize(&p->FifthSkill, serializer);
        Button.Serialize(&p->FirstSkill, serializer);
        Button.Serialize(&p->FourthSkill, serializer);
        Button.Serialize(&p->MainWeaponFire, serializer);
        Button.Serialize(&p->MouseLeftButton, serializer);
        Button.Serialize(&p->NinthSkill, serializer);
        Button.Serialize(&p->Return, serializer);
        Button.Serialize(&p->SecondSkill, serializer);
        Button.Serialize(&p->SeventhSkill, serializer);
        Button.Serialize(&p->SixthSkill, serializer);
        Button.Serialize(&p->TenthSkill, serializer);
        Button.Serialize(&p->ThirdSkill, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCCollision {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCCollisionSource Source;
    [FieldOffset(16)]
    public EntityRef Reference;
    [FieldOffset(8)]
    public AssetRef Processor;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7523;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCCollision*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCData {
    public const Int32 SIZE = 528;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public QBoolean IsActive;
    [FieldOffset(72)]
    public FP LookPitch;
    [FieldOffset(80)]
    public FP LookYaw;
    [FieldOffset(120)]
    public FPVector3 BasePosition;
    [FieldOffset(144)]
    public FPVector3 DesiredPosition;
    [FieldOffset(504)]
    public FPVector3 TargetPosition;
    [FieldOffset(40)]
    public FP DeltaTime;
    [FieldOffset(360)]
    public FPVector3 InputDirection;
    [FieldOffset(384)]
    public FPVector3 JumpImpulse;
    [FieldOffset(264)]
    public FPVector3 Gravity;
    [FieldOffset(88)]
    public FP MaxGroundAngle;
    [FieldOffset(104)]
    public FP MaxWallAngle;
    [FieldOffset(96)]
    public FP MaxHangAngle;
    [FieldOffset(240)]
    public FPVector3 ExternalImpulse;
    [FieldOffset(216)]
    public FPVector3 ExternalForce;
    [FieldOffset(192)]
    public FPVector3 ExternalDelta;
    [FieldOffset(64)]
    public FP KinematicSpeed;
    [FieldOffset(432)]
    public FPVector3 KinematicTangent;
    [FieldOffset(408)]
    public FPVector3 KinematicDirection;
    [FieldOffset(456)]
    public FPVector3 KinematicVelocity;
    [FieldOffset(168)]
    public FPVector3 DynamicVelocity;
    [FieldOffset(112)]
    public FP RealSpeed;
    [FieldOffset(480)]
    public FPVector3 RealVelocity;
    [FieldOffset(0)]
    public QBoolean HasJumped;
    [FieldOffset(4)]
    public QBoolean HasTeleported;
    [FieldOffset(12)]
    public QBoolean IsGrounded;
    [FieldOffset(24)]
    public QBoolean WasGrounded;
    [FieldOffset(20)]
    public QBoolean IsSteppingUp;
    [FieldOffset(32)]
    public QBoolean WasSteppingUp;
    [FieldOffset(16)]
    public QBoolean IsSnappingToGround;
    [FieldOffset(28)]
    public QBoolean WasSnappingToGround;
    [FieldOffset(288)]
    public FPVector3 GroundNormal;
    [FieldOffset(336)]
    public FPVector3 GroundTangent;
    [FieldOffset(312)]
    public FPVector3 GroundPosition;
    [FieldOffset(56)]
    public FP GroundDistance;
    [FieldOffset(48)]
    public FP GroundAngle;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6067;
        hash = hash * 31 + IsActive.GetHashCode();
        hash = hash * 31 + LookPitch.GetHashCode();
        hash = hash * 31 + LookYaw.GetHashCode();
        hash = hash * 31 + BasePosition.GetHashCode();
        hash = hash * 31 + DesiredPosition.GetHashCode();
        hash = hash * 31 + TargetPosition.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + InputDirection.GetHashCode();
        hash = hash * 31 + JumpImpulse.GetHashCode();
        hash = hash * 31 + Gravity.GetHashCode();
        hash = hash * 31 + MaxGroundAngle.GetHashCode();
        hash = hash * 31 + MaxWallAngle.GetHashCode();
        hash = hash * 31 + MaxHangAngle.GetHashCode();
        hash = hash * 31 + ExternalImpulse.GetHashCode();
        hash = hash * 31 + ExternalForce.GetHashCode();
        hash = hash * 31 + ExternalDelta.GetHashCode();
        hash = hash * 31 + KinematicSpeed.GetHashCode();
        hash = hash * 31 + KinematicTangent.GetHashCode();
        hash = hash * 31 + KinematicDirection.GetHashCode();
        hash = hash * 31 + KinematicVelocity.GetHashCode();
        hash = hash * 31 + DynamicVelocity.GetHashCode();
        hash = hash * 31 + RealSpeed.GetHashCode();
        hash = hash * 31 + RealVelocity.GetHashCode();
        hash = hash * 31 + HasJumped.GetHashCode();
        hash = hash * 31 + HasTeleported.GetHashCode();
        hash = hash * 31 + IsGrounded.GetHashCode();
        hash = hash * 31 + WasGrounded.GetHashCode();
        hash = hash * 31 + IsSteppingUp.GetHashCode();
        hash = hash * 31 + WasSteppingUp.GetHashCode();
        hash = hash * 31 + IsSnappingToGround.GetHashCode();
        hash = hash * 31 + WasSnappingToGround.GetHashCode();
        hash = hash * 31 + GroundNormal.GetHashCode();
        hash = hash * 31 + GroundTangent.GetHashCode();
        hash = hash * 31 + GroundPosition.GetHashCode();
        hash = hash * 31 + GroundDistance.GetHashCode();
        hash = hash * 31 + GroundAngle.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCData*)ptr;
        QBoolean.Serialize(&p->HasJumped, serializer);
        QBoolean.Serialize(&p->HasTeleported, serializer);
        QBoolean.Serialize(&p->IsActive, serializer);
        QBoolean.Serialize(&p->IsGrounded, serializer);
        QBoolean.Serialize(&p->IsSnappingToGround, serializer);
        QBoolean.Serialize(&p->IsSteppingUp, serializer);
        QBoolean.Serialize(&p->WasGrounded, serializer);
        QBoolean.Serialize(&p->WasSnappingToGround, serializer);
        QBoolean.Serialize(&p->WasSteppingUp, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        FP.Serialize(&p->GroundAngle, serializer);
        FP.Serialize(&p->GroundDistance, serializer);
        FP.Serialize(&p->KinematicSpeed, serializer);
        FP.Serialize(&p->LookPitch, serializer);
        FP.Serialize(&p->LookYaw, serializer);
        FP.Serialize(&p->MaxGroundAngle, serializer);
        FP.Serialize(&p->MaxHangAngle, serializer);
        FP.Serialize(&p->MaxWallAngle, serializer);
        FP.Serialize(&p->RealSpeed, serializer);
        FPVector3.Serialize(&p->BasePosition, serializer);
        FPVector3.Serialize(&p->DesiredPosition, serializer);
        FPVector3.Serialize(&p->DynamicVelocity, serializer);
        FPVector3.Serialize(&p->ExternalDelta, serializer);
        FPVector3.Serialize(&p->ExternalForce, serializer);
        FPVector3.Serialize(&p->ExternalImpulse, serializer);
        FPVector3.Serialize(&p->Gravity, serializer);
        FPVector3.Serialize(&p->GroundNormal, serializer);
        FPVector3.Serialize(&p->GroundPosition, serializer);
        FPVector3.Serialize(&p->GroundTangent, serializer);
        FPVector3.Serialize(&p->InputDirection, serializer);
        FPVector3.Serialize(&p->JumpImpulse, serializer);
        FPVector3.Serialize(&p->KinematicDirection, serializer);
        FPVector3.Serialize(&p->KinematicTangent, serializer);
        FPVector3.Serialize(&p->KinematicVelocity, serializer);
        FPVector3.Serialize(&p->RealVelocity, serializer);
        FPVector3.Serialize(&p->TargetPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCIgnore {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public EKCCIgnoreSource Source;
    [FieldOffset(8)]
    public EntityRef Reference;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 283;
        hash = hash * 31 + (Byte)Source;
        hash = hash * 31 + Reference.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCIgnore*)ptr;
        serializer.Stream.Serialize((Byte*)&p->Source);
        EntityRef.Serialize(&p->Reference, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCModifier {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef Processor;
    [FieldOffset(8)]
    public EntityRef Entity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15959;
        hash = hash * 31 + Processor.GetHashCode();
        hash = hash * 31 + Entity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCModifier*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
        EntityRef.Serialize(&p->Entity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerData {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QBoolean ready;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10271;
        hash = hash * 31 + ready.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerData*)ptr;
        QBoolean.Serialize(&p->ready, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Skill {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public SkillStatus Status;
    [FieldOffset(16)]
    public FP RemainingCastingTime;
    [FieldOffset(24)]
    public FP RemainingCoolTime;
    [FieldOffset(8)]
    public AssetRef<SkillData> SkillData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 6287;
        hash = hash * 31 + (Int32)Status;
        hash = hash * 31 + RemainingCastingTime.GetHashCode();
        hash = hash * 31 + RemainingCoolTime.GetHashCode();
        hash = hash * 31 + SkillData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Skill*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Status);
        AssetRef.Serialize(&p->SkillData, serializer);
        FP.Serialize(&p->RemainingCastingTime, serializer);
        FP.Serialize(&p->RemainingCoolTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Weapon {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean IsRecharging;
    [FieldOffset(0)]
    public Int32 CurrentAmmo;
    [FieldOffset(32)]
    public FP FireRateTimer;
    [FieldOffset(24)]
    public FP DelayToStartRechargeTimer;
    [FieldOffset(40)]
    public FP RechargeRate;
    [FieldOffset(16)]
    public FP ChargeTime;
    [FieldOffset(8)]
    public AssetRef<PrimaryWeaponData> WeaponData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8713;
        hash = hash * 31 + IsRecharging.GetHashCode();
        hash = hash * 31 + CurrentAmmo.GetHashCode();
        hash = hash * 31 + FireRateTimer.GetHashCode();
        hash = hash * 31 + DelayToStartRechargeTimer.GetHashCode();
        hash = hash * 31 + RechargeRate.GetHashCode();
        hash = hash * 31 + ChargeTime.GetHashCode();
        hash = hash * 31 + WeaponData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Weapon*)ptr;
        serializer.Stream.Serialize(&p->CurrentAmmo);
        QBoolean.Serialize(&p->IsRecharging, serializer);
        AssetRef.Serialize(&p->WeaponData, serializer);
        FP.Serialize(&p->ChargeTime, serializer);
        FP.Serialize(&p->DelayToStartRechargeTimer, serializer);
        FP.Serialize(&p->FireRateTimer, serializer);
        FP.Serialize(&p->RechargeRate, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1768;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(120)]
    public BitSet1024 Systems;
    [FieldOffset(248)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(536)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(544)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[1152];
    [FieldOffset(1696)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1752)]
    public GameController GameController;
    [FieldOffset(1716)]
    public Int32 ClientConnectUsers;
    [FieldOffset(1736)]
    public FP StateTimer;
    [FieldOffset(1708)]
    public GameState DelayedState;
    [FieldOffset(1704)]
    public GameState CurrentState;
    [FieldOffset(1712)]
    public GameState PreviousState;
    [FieldOffset(1744)]
    public FP clock;
    [FieldOffset(1720)]
    public Int32 TeamIndex;
    [FieldOffset(1728)]
    public FP DisconnectTime;
    [FieldOffset(1724)]
    public QDictionaryPtr<Int32, PlayerData> teamData;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 192, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + GameController.GetHashCode();
        hash = hash * 31 + ClientConnectUsers.GetHashCode();
        hash = hash * 31 + StateTimer.GetHashCode();
        hash = hash * 31 + (Int32)DelayedState;
        hash = hash * 31 + (Int32)CurrentState;
        hash = hash * 31 + (Int32)PreviousState;
        hash = hash * 31 + clock.GetHashCode();
        hash = hash * 31 + TeamIndex.GetHashCode();
        hash = hash * 31 + DisconnectTime.GetHashCode();
        hash = hash * 31 + teamData.GetHashCode();
        return hash;
      }
    }
    partial void ClearPointersPartial(FrameBase f, EntityRef entity) {
      teamData = default;
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize((Int32*)&p->CurrentState);
        serializer.Stream.Serialize((Int32*)&p->DelayedState);
        serializer.Stream.Serialize((Int32*)&p->PreviousState);
        serializer.Stream.Serialize(&p->ClientConnectUsers);
        serializer.Stream.Serialize(&p->TeamIndex);
        QDictionary.Serialize(&p->teamData, serializer, Statics.SerializeInt32, Statics.SerializePlayerData);
        FP.Serialize(&p->DisconnectTime, serializer);
        FP.Serialize(&p->StateTimer, serializer);
        FP.Serialize(&p->clock, serializer);
        Quantum.GameController.Serialize(&p->GameController, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AbilityInventory : Quantum.IComponent {
    public const Int32 SIZE = 280;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(192)]
    [ExcludeFromPrototype()]
    public ActiveAbilityInfo ActiveAbilityInfo;
    [FieldOffset(0)]
    [Header("Ability Order: Dash, OrbitalSupport, Return")]
    [FramePrinter.FixedArrayAttribute(typeof(Ability), 3)]
    private fixed Byte _Abilities_[192];
    public FixedArray<Ability> Abilities {
      get {
        fixed (byte* p = _Abilities_) { return new FixedArray<Ability>(p, 64, 3); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13523;
        hash = hash * 31 + ActiveAbilityInfo.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(Abilities);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AbilityInventory*)ptr;
        FixedArray.Serialize(p->Abilities, serializer, Statics.SerializeAbility);
        Quantum.ActiveAbilityInfo.Serialize(&p->ActiveAbilityInfo, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BulletFields : Quantum.IComponent {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP Time;
    [FieldOffset(8)]
    public EntityRef Source;
    [FieldOffset(24)]
    public FPVector3 Direction;
    [FieldOffset(0)]
    public AssetRef<BulletData> BulletData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20201;
        hash = hash * 31 + Time.GetHashCode();
        hash = hash * 31 + Source.GetHashCode();
        hash = hash * 31 + Direction.GetHashCode();
        hash = hash * 31 + BulletData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BulletFields*)ptr;
        AssetRef.Serialize(&p->BulletData, serializer);
        EntityRef.Serialize(&p->Source, serializer);
        FP.Serialize(&p->Time, serializer);
        FPVector3.Serialize(&p->Direction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CenterTowerFields : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP Time;
    [FieldOffset(8)]
    public FP FirstDelayTime;
    [FieldOffset(0)]
    public FP Damage;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 139;
        hash = hash * 31 + Time.GetHashCode();
        hash = hash * 31 + FirstDelayTime.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CenterTowerFields*)ptr;
        FP.Serialize(&p->Damage, serializer);
        FP.Serialize(&p->FirstDelayTime, serializer);
        FP.Serialize(&p->Time, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct FootboardIdentifier : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5197;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (FootboardIdentifier*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCC : Quantum.IComponent {
    public const Int32 SIZE = 552;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<KCCSettings> Settings;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public QBoolean IsInitialized;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public KCCData Data;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QHashSetPtr<KCCIgnore> Ignores;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCModifier> Modifiers;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QListPtr<KCCCollision> Collisions;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 659;
        hash = hash * 31 + Settings.GetHashCode();
        hash = hash * 31 + IsInitialized.GetHashCode();
        hash = hash * 31 + Data.GetHashCode();
        hash = hash * 31 + Ignores.GetHashCode();
        hash = hash * 31 + Modifiers.GetHashCode();
        hash = hash * 31 + Collisions.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Ignores = default;
      Modifiers = default;
      Collisions = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.KCC*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCC*)ptr;
        QBoolean.Serialize(&p->IsInitialized, serializer);
        QHashSet.Serialize(&p->Ignores, serializer, Statics.SerializeKCCIgnore);
        QList.Serialize(&p->Collisions, serializer, Statics.SerializeKCCCollision);
        QList.Serialize(&p->Modifiers, serializer, Statics.SerializeKCCModifier);
        AssetRef.Serialize(&p->Settings, serializer);
        Quantum.KCCData.Serialize(&p->Data, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct KCCProcessorLink : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<KCCProcessor> Processor;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13411;
        hash = hash * 31 + Processor.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (KCCProcessorLink*)ptr;
        AssetRef.Serialize(&p->Processor, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct MechProjectile : Quantum.IComponent {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP TTL;
    [FieldOffset(0)]
    public EntityRef Owner;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11113;
        hash = hash * 31 + TTL.GetHashCode();
        hash = hash * 31 + Owner.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (MechProjectile*)ptr;
        EntityRef.Serialize(&p->Owner, serializer);
        FP.Serialize(&p->TTL, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Nexus : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(12)]
    public Team Team;
    [FieldOffset(16)]
    public FP CurrentHealth;
    [FieldOffset(0)]
    public QBoolean IsDestroy;
    [FieldOffset(8)]
    public QBoolean IsTeamDefeat;
    [FieldOffset(4)]
    public QBoolean IsJoin;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2557;
        hash = hash * 31 + (Int32)Team;
        hash = hash * 31 + CurrentHealth.GetHashCode();
        hash = hash * 31 + IsDestroy.GetHashCode();
        hash = hash * 31 + IsTeamDefeat.GetHashCode();
        hash = hash * 31 + IsJoin.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Nexus*)ptr;
        QBoolean.Serialize(&p->IsDestroy, serializer);
        QBoolean.Serialize(&p->IsJoin, serializer);
        QBoolean.Serialize(&p->IsTeamDefeat, serializer);
        serializer.Stream.Serialize((Int32*)&p->Team);
        FP.Serialize(&p->CurrentHealth, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayableMechanic : Quantum.IComponent {
    public const Int32 SIZE = 40;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public Team Team;
    [FieldOffset(8)]
    public Skill ReturnSkill;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8783;
        hash = hash * 31 + (Int32)Team;
        hash = hash * 31 + ReturnSkill.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayableMechanic*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Team);
        Quantum.Skill.Serialize(&p->ReturnSkill, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef PlayerRef;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + PlayerRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->PlayerRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SkillInventory : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<Skill> Skills;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1319;
        hash = hash * 31 + Skills.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Skills = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.SkillInventory*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SkillInventory*)ptr;
        QList.Serialize(&p->Skills, serializer, Statics.SerializeSkill);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct SpawnIdentifier : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Team Team;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11057;
        hash = hash * 31 + (Int32)Team;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (SpawnIdentifier*)ptr;
        serializer.Stream.Serialize((Int32*)&p->Team);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Status : Quantum.IComponent {
    public const Int32 SIZE = 56;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP CurrentHealth;
    [FieldOffset(4)]
    public QBoolean IsDead;
    [FieldOffset(48)]
    public FP RespawnTimer;
    [FieldOffset(40)]
    public FP RegenTimer;
    [FieldOffset(32)]
    public FP InvincibleTimer;
    [FieldOffset(0)]
    public Int32 DisconnectedTicks;
    [FieldOffset(16)]
    public AssetRef<StatusData> StatusData;
    [FieldOffset(8)]
    public AssetRef<PlayerMovementData> PlayerMovementData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7673;
        hash = hash * 31 + CurrentHealth.GetHashCode();
        hash = hash * 31 + IsDead.GetHashCode();
        hash = hash * 31 + RespawnTimer.GetHashCode();
        hash = hash * 31 + RegenTimer.GetHashCode();
        hash = hash * 31 + InvincibleTimer.GetHashCode();
        hash = hash * 31 + DisconnectedTicks.GetHashCode();
        hash = hash * 31 + StatusData.GetHashCode();
        hash = hash * 31 + PlayerMovementData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (Status*)ptr;
        serializer.Stream.Serialize(&p->DisconnectedTicks);
        QBoolean.Serialize(&p->IsDead, serializer);
        AssetRef.Serialize(&p->PlayerMovementData, serializer);
        AssetRef.Serialize(&p->StatusData, serializer);
        FP.Serialize(&p->CurrentHealth, serializer);
        FP.Serialize(&p->InvincibleTimer, serializer);
        FP.Serialize(&p->RegenTimer, serializer);
        FP.Serialize(&p->RespawnTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TrapFields : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public FP DelayElapsedTime;
    [FieldOffset(8)]
    public EntityRef Source;
    [FieldOffset(0)]
    public AssetRef<TrapData> TrapData;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7027;
        hash = hash * 31 + DelayElapsedTime.GetHashCode();
        hash = hash * 31 + Source.GetHashCode();
        hash = hash * 31 + TrapData.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TrapFields*)ptr;
        AssetRef.Serialize(&p->TrapData, serializer);
        EntityRef.Serialize(&p->Source, serializer);
        FP.Serialize(&p->DelayElapsedTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct WeaponInventory : Quantum.IComponent {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 CurrentWeaponIndex;
    [FieldOffset(4)]
    public QListPtr<Weapon> Weapons;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4513;
        hash = hash * 31 + CurrentWeaponIndex.GetHashCode();
        hash = hash * 31 + Weapons.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Weapons = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.WeaponInventory*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (WeaponInventory*)ptr;
        serializer.Stream.Serialize(&p->CurrentWeaponIndex);
        QList.Serialize(&p->Weapons, serializer, Statics.SerializeWeapon);
    }
  }
  public unsafe partial interface ISignalOnCooldownsReset : ISignal {
    void OnCooldownsReset(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalOnActiveAbilityStopped : ISignal {
    void OnActiveAbilityStopped(Frame f, EntityRef playerEntityRef);
  }
  public unsafe partial interface ISignalSpawnMechanic : ISignal {
    void SpawnMechanic(Frame f, EntityRef mechanic);
  }
  public unsafe partial interface ISignalOnMechanicRespawn : ISignal {
    void OnMechanicRespawn(Frame f, EntityRef robot);
  }
  public unsafe partial interface ISignalOnMechanicHit : ISignal {
    void OnMechanicHit(Frame f, EntityRef bullet, EntityRef robot, FP damage);
  }
  public unsafe partial interface ISignalOnMechanicSkillHit : ISignal {
    void OnMechanicSkillHit(Frame f, EntityRef skill, EntityRef robot);
  }
  public unsafe partial interface ISignalOnMechanicDeath : ISignal {
    void OnMechanicDeath(Frame f, EntityRef deadRobot, EntityRef killer);
  }
  public unsafe partial interface ISignalOnMechanicTeleport : ISignal {
    void OnMechanicTeleport(Frame f, EntityRef mechanic, FPVector3 position);
  }
  public unsafe partial interface ISignalOnGameEnded : ISignal {
    void OnGameEnded(Frame f, GameController* gameController);
  }
  public unsafe partial interface ISignalGameStateChanged : ISignal {
    void GameStateChanged(Frame f, GameState state);
  }
  public unsafe partial interface ISignalPlayerKilled : ISignal {
    void PlayerKilled(Frame f, EntityRef target, EntityRef killer);
  }
  public unsafe partial interface ISignalPlayerNexusDestoryed : ISignal {
    void PlayerNexusDestoryed(Frame f, Team team);
  }
  public unsafe partial interface ISignalOnNexusHit : ISignal {
    void OnNexusHit(Frame f, EntityRef bullet, EntityRef nexus, FP damage);
  }
  public unsafe partial interface ISignalOnNexusDestroy : ISignal {
    void OnNexusDestroy(Frame f, EntityRef nexus, EntityRef killer);
  }
  public unsafe partial interface ISignalOnTeamDefeat : ISignal {
    void OnTeamDefeat(Frame f, Team Team);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalOnCooldownsReset[] _ISignalOnCooldownsResetSystems;
    private ISignalOnActiveAbilityStopped[] _ISignalOnActiveAbilityStoppedSystems;
    private ISignalSpawnMechanic[] _ISignalSpawnMechanicSystems;
    private ISignalOnMechanicRespawn[] _ISignalOnMechanicRespawnSystems;
    private ISignalOnMechanicHit[] _ISignalOnMechanicHitSystems;
    private ISignalOnMechanicSkillHit[] _ISignalOnMechanicSkillHitSystems;
    private ISignalOnMechanicDeath[] _ISignalOnMechanicDeathSystems;
    private ISignalOnMechanicTeleport[] _ISignalOnMechanicTeleportSystems;
    private ISignalOnGameEnded[] _ISignalOnGameEndedSystems;
    private ISignalGameStateChanged[] _ISignalGameStateChangedSystems;
    private ISignalPlayerKilled[] _ISignalPlayerKilledSystems;
    private ISignalPlayerNexusDestoryed[] _ISignalPlayerNexusDestoryedSystems;
    private ISignalOnNexusHit[] _ISignalOnNexusHitSystems;
    private ISignalOnNexusDestroy[] _ISignalOnNexusDestroySystems;
    private ISignalOnTeamDefeat[] _ISignalOnTeamDefeatSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnCooldownsResetSystems = BuildSignalsArray<ISignalOnCooldownsReset>();
      _ISignalOnActiveAbilityStoppedSystems = BuildSignalsArray<ISignalOnActiveAbilityStopped>();
      _ISignalSpawnMechanicSystems = BuildSignalsArray<ISignalSpawnMechanic>();
      _ISignalOnMechanicRespawnSystems = BuildSignalsArray<ISignalOnMechanicRespawn>();
      _ISignalOnMechanicHitSystems = BuildSignalsArray<ISignalOnMechanicHit>();
      _ISignalOnMechanicSkillHitSystems = BuildSignalsArray<ISignalOnMechanicSkillHit>();
      _ISignalOnMechanicDeathSystems = BuildSignalsArray<ISignalOnMechanicDeath>();
      _ISignalOnMechanicTeleportSystems = BuildSignalsArray<ISignalOnMechanicTeleport>();
      _ISignalOnGameEndedSystems = BuildSignalsArray<ISignalOnGameEnded>();
      _ISignalGameStateChangedSystems = BuildSignalsArray<ISignalGameStateChanged>();
      _ISignalPlayerKilledSystems = BuildSignalsArray<ISignalPlayerKilled>();
      _ISignalPlayerNexusDestoryedSystems = BuildSignalsArray<ISignalPlayerNexusDestoryed>();
      _ISignalOnNexusHitSystems = BuildSignalsArray<ISignalOnNexusHit>();
      _ISignalOnNexusDestroySystems = BuildSignalsArray<ISignalOnNexusDestroy>();
      _ISignalOnTeamDefeatSystems = BuildSignalsArray<ISignalOnTeamDefeat>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AbilityInventory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AbilityInventory>();
      BuildSignalsArrayOnComponentAdded<Quantum.BulletFields>();
      BuildSignalsArrayOnComponentRemoved<Quantum.BulletFields>();
      BuildSignalsArrayOnComponentAdded<Quantum.CenterTowerFields>();
      BuildSignalsArrayOnComponentRemoved<Quantum.CenterTowerFields>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.FootboardIdentifier>();
      BuildSignalsArrayOnComponentRemoved<Quantum.FootboardIdentifier>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCC>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCC>();
      BuildSignalsArrayOnComponentAdded<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.KCCProcessorLink>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.MechProjectile>();
      BuildSignalsArrayOnComponentRemoved<Quantum.MechProjectile>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<Quantum.Nexus>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Nexus>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayableMechanic>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayableMechanic>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.SkillInventory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SkillInventory>();
      BuildSignalsArrayOnComponentAdded<Quantum.SpawnIdentifier>();
      BuildSignalsArrayOnComponentRemoved<Quantum.SpawnIdentifier>();
      BuildSignalsArrayOnComponentAdded<Quantum.Status>();
      BuildSignalsArrayOnComponentRemoved<Quantum.Status>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.TrapFields>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TrapFields>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
      BuildSignalsArrayOnComponentAdded<Quantum.WeaponInventory>();
      BuildSignalsArrayOnComponentRemoved<Quantum.WeaponInventory>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->MovementEncoded = input.MovementEncoded;
      i->MouseLeftButton = i->MouseLeftButton.Update(this.Number, input.MouseLeftButton);
      i->ScreenPositionX = input.ScreenPositionX;
      i->ScreenPositionY = input.ScreenPositionY;
      i->MainWeaponFire = i->MainWeaponFire.Update(this.Number, input.MainWeaponFire);
      i->FirstSkill = i->FirstSkill.Update(this.Number, input.FirstSkill);
      i->SecondSkill = i->SecondSkill.Update(this.Number, input.SecondSkill);
      i->ThirdSkill = i->ThirdSkill.Update(this.Number, input.ThirdSkill);
      i->FourthSkill = i->FourthSkill.Update(this.Number, input.FourthSkill);
      i->FifthSkill = i->FifthSkill.Update(this.Number, input.FifthSkill);
      i->SixthSkill = i->SixthSkill.Update(this.Number, input.SixthSkill);
      i->SeventhSkill = i->SeventhSkill.Update(this.Number, input.SeventhSkill);
      i->EighthSkill = i->EighthSkill.Update(this.Number, input.EighthSkill);
      i->NinthSkill = i->NinthSkill.Update(this.Number, input.NinthSkill);
      i->TenthSkill = i->TenthSkill.Update(this.Number, input.TenthSkill);
      i->Return = i->Return.Update(this.Number, input.Return);
      i->ChangeWeapon = i->ChangeWeapon.Update(this.Number, input.ChangeWeapon);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnCooldownsReset(EntityRef playerEntityRef) {
        var array = _f._ISignalOnCooldownsResetSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCooldownsReset(_f, playerEntityRef);
          }
        }
      }
      public void OnActiveAbilityStopped(EntityRef playerEntityRef) {
        var array = _f._ISignalOnActiveAbilityStoppedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnActiveAbilityStopped(_f, playerEntityRef);
          }
        }
      }
      public void SpawnMechanic(EntityRef mechanic) {
        var array = _f._ISignalSpawnMechanicSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.SpawnMechanic(_f, mechanic);
          }
        }
      }
      public void OnMechanicRespawn(EntityRef robot) {
        var array = _f._ISignalOnMechanicRespawnSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMechanicRespawn(_f, robot);
          }
        }
      }
      public void OnMechanicHit(EntityRef bullet, EntityRef robot, FP damage) {
        var array = _f._ISignalOnMechanicHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMechanicHit(_f, bullet, robot, damage);
          }
        }
      }
      public void OnMechanicSkillHit(EntityRef skill, EntityRef robot) {
        var array = _f._ISignalOnMechanicSkillHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMechanicSkillHit(_f, skill, robot);
          }
        }
      }
      public void OnMechanicDeath(EntityRef deadRobot, EntityRef killer) {
        var array = _f._ISignalOnMechanicDeathSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMechanicDeath(_f, deadRobot, killer);
          }
        }
      }
      public void OnMechanicTeleport(EntityRef mechanic, FPVector3 position) {
        var array = _f._ISignalOnMechanicTeleportSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnMechanicTeleport(_f, mechanic, position);
          }
        }
      }
      public void OnGameEnded(GameController* gameController) {
        var array = _f._ISignalOnGameEndedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnGameEnded(_f, gameController);
          }
        }
      }
      public void GameStateChanged(GameState state) {
        var array = _f._ISignalGameStateChangedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.GameStateChanged(_f, state);
          }
        }
      }
      public void PlayerKilled(EntityRef target, EntityRef killer) {
        var array = _f._ISignalPlayerKilledSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.PlayerKilled(_f, target, killer);
          }
        }
      }
      public void PlayerNexusDestoryed(Team team) {
        var array = _f._ISignalPlayerNexusDestoryedSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.PlayerNexusDestoryed(_f, team);
          }
        }
      }
      public void OnNexusHit(EntityRef bullet, EntityRef nexus, FP damage) {
        var array = _f._ISignalOnNexusHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnNexusHit(_f, bullet, nexus, damage);
          }
        }
      }
      public void OnNexusDestroy(EntityRef nexus, EntityRef killer) {
        var array = _f._ISignalOnNexusDestroySystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnNexusDestroy(_f, nexus, killer);
          }
        }
      }
      public void OnTeamDefeat(Team Team) {
        var array = _f._ISignalOnTeamDefeatSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTeamDefeat(_f, Team);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAbility;
    public static FrameSerializer.Delegate SerializeKCCCollision;
    public static FrameSerializer.Delegate SerializeKCCIgnore;
    public static FrameSerializer.Delegate SerializeKCCModifier;
    public static FrameSerializer.Delegate SerializeSkill;
    public static FrameSerializer.Delegate SerializeWeapon;
    public static FrameSerializer.Delegate SerializeInput;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializePlayerData;
    static partial void InitStaticDelegatesGen() {
      SerializeAbility = Quantum.Ability.Serialize;
      SerializeKCCCollision = Quantum.KCCCollision.Serialize;
      SerializeKCCIgnore = Quantum.KCCIgnore.Serialize;
      SerializeKCCModifier = Quantum.KCCModifier.Serialize;
      SerializeSkill = Quantum.Skill.Serialize;
      SerializeWeapon = Quantum.Weapon.Serialize;
      SerializeInput = Quantum.Input.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializePlayerData = Quantum.PlayerData.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.Ability), Quantum.Ability.SIZE);
      typeRegistry.Register(typeof(Quantum.AbilityInventory), Quantum.AbilityInventory.SIZE);
      typeRegistry.Register(typeof(Quantum.AbilityType), 4);
      typeRegistry.Register(typeof(Quantum.ActiveAbilityInfo), Quantum.ActiveAbilityInfo.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.BulletFields), Quantum.BulletFields.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(Quantum.CenterTowerFields), Quantum.CenterTowerFields.SIZE);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CountdownTimer), Quantum.CountdownTimer.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.EAbilityEndCondition), 4);
      typeRegistry.Register(typeof(Quantum.EHitTargetType), 4);
      typeRegistry.Register(typeof(Quantum.EKCCCollisionSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCIgnoreSource), 1);
      typeRegistry.Register(typeof(Quantum.EKCCProcessorSource), 1);
      typeRegistry.Register(typeof(Quantum.ESpreadDirection), 4);
      typeRegistry.Register(typeof(Quantum.ESpreadShape), 4);
      typeRegistry.Register(typeof(Quantum.EWeaponType), 4);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(Quantum.FootboardIdentifier), Quantum.FootboardIdentifier.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameController), Quantum.GameController.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.KCC), Quantum.KCC.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCCollision), Quantum.KCCCollision.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCData), Quantum.KCCData.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCIgnore), Quantum.KCCIgnore.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCModifier), Quantum.KCCModifier.SIZE);
      typeRegistry.Register(typeof(Quantum.KCCProcessorLink), Quantum.KCCProcessorLink.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(Quantum.MechProjectile), Quantum.MechProjectile.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(Quantum.Nexus), Quantum.Nexus.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayableMechanic), Quantum.PlayableMechanic.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerData), Quantum.PlayerData.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Skill), Quantum.Skill.SIZE);
      typeRegistry.Register(typeof(Quantum.SkillInventory), Quantum.SkillInventory.SIZE);
      typeRegistry.Register(typeof(Quantum.SkillStatus), 4);
      typeRegistry.Register(typeof(Quantum.SpawnIdentifier), Quantum.SpawnIdentifier.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Status), Quantum.Status.SIZE);
      typeRegistry.Register(typeof(Quantum.Team), 4);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(Quantum.TrapFields), Quantum.TrapFields.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum.Weapon), Quantum.Weapon.SIZE);
      typeRegistry.Register(typeof(Quantum.WeaponInventory), Quantum.WeaponInventory.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 15)
        .AddBuiltInComponents()
        .Add<Quantum.AbilityInventory>(Quantum.AbilityInventory.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.BulletFields>(Quantum.BulletFields.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.CenterTowerFields>(Quantum.CenterTowerFields.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.FootboardIdentifier>(Quantum.FootboardIdentifier.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.KCC>(Quantum.KCC.Serialize, null, Quantum.KCC.OnRemoved, ComponentFlags.None)
        .Add<Quantum.KCCProcessorLink>(Quantum.KCCProcessorLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.MechProjectile>(Quantum.MechProjectile.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Nexus>(Quantum.Nexus.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayableMechanic>(Quantum.PlayableMechanic.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.SkillInventory>(Quantum.SkillInventory.Serialize, null, Quantum.SkillInventory.OnRemoved, ComponentFlags.None)
        .Add<Quantum.SpawnIdentifier>(Quantum.SpawnIdentifier.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.Status>(Quantum.Status.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TrapFields>(Quantum.TrapFields.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.WeaponInventory>(Quantum.WeaponInventory.Serialize, null, Quantum.WeaponInventory.OnRemoved, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AbilityType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EAbilityEndCondition>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EHitTargetType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCCollisionSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCIgnoreSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EKCCProcessorSource>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ESpreadDirection>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ESpreadShape>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EWeaponType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.SkillStatus>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.Team>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
